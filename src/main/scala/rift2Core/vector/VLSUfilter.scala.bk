
// /*
//   Copyright (c) 2020 - 2023 Wuhan University of Technology <295054118@whut.edu.cn>

//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at

//        http://www.apache.org/licenses/LICENSE-2.0

//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
// */

// package rift2Core.backend.lsu

// import chisel3._
// import chisel3.util._

// import rift2Core.define._
// import rift2Chip._

// import rift2Core.privilege._
// import rift2Core.backend._

// import chipsalliance.rocketchip.config.Parameters
// import freechips.rocketchip.tilelink._



// abstract class VLSUFilterBase()(implicit p: Parameters) extends RiftModule{
//   val dEdge = edge

//   val io = IO(new Bundle{
//     val enq = Flipped(new DecoupledIO(new Lsu_iss_info))
//     val deq = Flipped(new DecoupledIO(new Lsu_iss_info))
//   }

//   val pendingFifo = Module(new Queue(new Lsu_iss_info), 8, pipe = false, flow = true )

//   val vLSUFilterFifo = Module( new MultiPortFifo( new Lsu_iss_info, aw = log2Ceil(vParams.vlen/8), in = (vParams.vlen/8), out = 1 ) )

//   val isEmpty = ~vLSUFilterFifo.io.deq(0).valid

//   val isVectorRequest =  io.enq.bits.fun.isVLoad |  io.enq.bits.fun.isVStore

//   io.enq <> pendingFifo.io.enq
// }


// trait VLSUFilterMux{ this: VLSUFilterBase =>
//   // pendingFifo.io.deq.ready := false.B
//   // io.deq.valid := false.B
//   // io.deq.bits  := 0.U.asTypeOf(new Lsu_iss_info)




//   when( isVectorRequest ){

//   }.otherwise{ //isScalarRequest
//     when( isEmpty ){
//       pendingFifo.io.deq <> io.deq
//     }.otherwise{ //~isEmpty
//       pendingFifo.io.deq.ready := false.B
//       io.deq.valid := false.B
//       io.deq.bits  := 0.U.asTypeOf(new Lsu_iss_info)
//     }
//   }




// }



// object Pkg_VlsuScoreBoard_update{
//   def apply(ori: Lsu_iss_info, bufIdx: Int): (Vec[Bool], Vec[Lsu_iss_info]) = {
//     require(hasVector)

//     val isValid   = Wire(vParams.vlen/8, Bool())
//     val splitInfo = Wire(vParams.vlen/8, new Lsu_iss_info)


//     val sbInfo = Wire( new VLSU_Entry_Bundle )

//     val mask8  = Wire( UInt((vParams.vlen/8 ).W))
//     val mask16 = Wire( UInt((vParams.vlen/16).W))
//     val mask32 = Wire( UInt((vParams.vlen/32).W))
//     val mask64 = Wire( UInt((vParams.vlen/64).W))

//     val bodyTotal = Wire( Vec(vParams.vlmax, Bool()) )
//     val body8  = Wire( UInt((vParams.vlen/8 ).W))
//     val body16 = Wire( UInt((vParams.vlen/16).W))
//     val body32 = Wire( UInt((vParams.vlen/32).W))
//     val body64 = Wire( UInt((vParams.vlen/64).W))

//     val preStartTotal = Wire( Vec(vParams.vlmax, Bool()) )
//     val preStart8  = Wire( UInt((vParams.vlen/8 ).W))
//     val preStart16 = Wire( UInt((vParams.vlen/16).W))
//     val preStart32 = Wire( UInt((vParams.vlen/32).W))
//     val preStart64 = Wire( UInt((vParams.vlen/64).W))

//     val tailTotal = Wire( Vec(vParams.vlmax, Bool()) )
//     val tail8  = Wire( UInt((vParams.vlen/8 ).W))
//     val tail16 = Wire( UInt((vParams.vlen/16).W))
//     val tail32 = Wire( UInt((vParams.vlen/32).W))
//     val tail64 = Wire( UInt((vParams.vlen/64).W))

//     val resInit8  = Wire( UInt((vParams.vlen).W) )
//     val resInit16 = Wire( UInt((vParams.vlen).W) )
//     val resInit32 = Wire( UInt((vParams.vlen).W) )
//     val resInit64 = Wire( UInt((vParams.vlen).W) )

//     mask8  := ori.param.op4(vParams.vlen/8-1,  0) | Fill( vParams.vlen/8,  ori.vAttach.get.vm )
//     mask16 := ori.param.op4(vParams.vlen/16-1, 0) | Fill( vParams.vlen/16, ori.vAttach.get.vm )
//     mask32 := ori.param.op4(vParams.vlen/32-1, 0) | Fill( vParams.vlen/32, ori.vAttach.get.vm )
//     mask64 := ori.param.op4(vParams.vlen/64-1, 0) | Fill( vParams.vlen/64, ori.vAttach.get.vm )
    

//     for( i <- 0 until vParams.vlmax ) {
//       preStartTotal(i) :=  i.U  < ori.vAttach.get.vstart
//       bodyTotal(i)     := (i.U >= ori.vAttach.get.vstart && i.U <= ori.vAttach.get.vl)
//       tailTotal(i)     :=                                   i.U  > ori.vAttach.get.vl
//     }

//     preStart8  := preStartTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/8))
//     preStart16 := preStartTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/16))
//     preStart32 := preStartTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/32))
//     preStart64 := preStartTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/64))

//     body8  := bodyTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/8))
//     body16 := bodyTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/16))
//     body32 := bodyTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/32))
//     body64 := bodyTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/64))

//     tail8  := tailTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/8))
//     tail16 := tailTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/16))
//     tail32 := tailTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/32))
//     tail64 := tailTotal.asUInt >> (ori.vAttach.get.group << log2Ceil(vParams.vlen/64))

//     sbInfo.isRequested := sbInfo.isWroteBack :=
//       Fill( vParams.vlen/8, 1.U) & ~(
//         Mux1H(Seq(
//           (ori.vAttach.get.vsew === "b000".U) -> (mask8 & body8),
//           (ori.vAttach.get.vsew === "b001".U) -> (mask16 & body16),
//           (ori.vAttach.get.vsew === "b010".U) -> (mask32 & body32),
//           (ori.vAttach.get.vsew === "b011".U) -> (mask64 & body64),
//         ))
//       )

//     sbInfo.isException := 0.U



//     resInit8 := Cat(
//       for( i <- 0 until vParams.vlen/8 ) yield {
//         Mux1H(Seq(
//           preStart8(i) -> ori.param.op3(8*i+7, 8*i),
//           body8(i)     -> Mux( mask8(i), 0.U(8.W),          Mux( ori.vAttach.get.vma, Fill(8, 1.U(1.W)), ori.param.op3(8*i+7, 8*i) ) ),
//           tail8(i)     -> Mux( mask8(i), Fill(8, 1.U(1.W)), Mux( ori.vAttach.get.vta, Fill(8, 1.U(1.W)), ori.param.op3(8*i+7, 8*i) ) ),
//         ))         
//       }.reverse
//     )

//     resInit16 := Cat(
//       for( i <- 0 until vParams.vlen/16 ) yield {
//         Mux1H(Seq(
//           preStart16(i) -> ori.param.op3(16*i+15, 16*i),
//           body16(i)     -> Mux( mask16(i), 0.U(16.W),          Mux( ori.vAttach.get.vma, Fill(16, 1.U(1.W)), ori.param.op3(16*i+15, 16*i) ) ),
//           tail16(i)     -> Mux( mask16(i), Fill(16, 1.U(1.W)), Mux( ori.vAttach.get.vta, Fill(16, 1.U(1.W)), ori.param.op3(16*i+15, 16*i) ) ),
//         ))         
//       }.reverse
//     )

//     resInit32 := Cat(
//       for( i <- 0 until vParams.vlen/32 ) yield {
//         Mux1H(Seq(
//           preStart32(i) -> ori.param.op3(32*i+31, 32*i),
//           body32(i)     -> Mux( mask32(i), 0.U(32.W),          Mux( ori.vAttach.get.vma, Fill(32, 1.U(1.W)), ori.param.op3(32*i+31, 32*i) ) ),
//           tail32(i)     -> Mux( mask32(i), Fill(32, 1.U(1.W)), Mux( ori.vAttach.get.vta, Fill(32, 1.U(1.W)), ori.param.op3(32*i+31, 32*i) ) ),
//         ))         
//       }.reverse
//     )

//     resInit64 := Cat(
//       for( i <- 0 until vParams.vlen/64 ) yield {
//         Mux1H(Seq(
//           preStart64(i) -> ori.param.op3(64*i+63, 64*i),
//           body64(i)     -> Mux( mask64(i), 0.U(64.W),          Mux( ori.vAttach.get.vma, Fill(64, 1.U(1.W)), ori.param.op3(64*i+63, 64*i) ) ),
//           tail64(i)     -> Mux( mask64(i), Fill(64, 1.U(1.W)), Mux( ori.vAttach.get.vta, Fill(64, 1.U(1.W)), ori.param.op3(64*i+63, 64*i) ) ),
//         ))         
//       }.reverse
//     )

//     sbInfo.res := 
//       Mux1H(Seq(
//         (ori.vAttach.get.vsew === "b000".U) -> resInit8,
//         (ori.vAttach.get.vsew === "b001".U) -> resInit16,
//         (ori.vAttach.get.vsew === "b010".U) -> resInit32,
//         (ori.vAttach.get.vsew === "b011".U) -> resInit64,
//       ))


//     sbInfo.originInfo := ori
//     sbInfo.splitInfo := 0.U.asTypeOf(sbInfo.splitInfo)


//     for( i <- 0 until vParams.vlen/8 ){
//       when( ~sbInfo.isRequested(i) ){
//         require( vParams.lsuEntry <= maxRegNum )
//         require( vParams.vlen/8   <= maxRegNum )
//         val eleIdx = i.U

//         sbInfo.splitInfo(i).param.rd0            := eleIdx
//         sbInfo.splitInfo(i).vAttach.get.entrySel := bufIdx
//         sbInfo.splitInfo(i).param.dat.op3 := DontCare
//         sbInfo.splitInfo(i).param.dat.op4 := DontCare

//         when( ori.fun.vle | iss.fun.vlm | iss.fun.vleNff | iss.fun.vleNff ){
//           println("Warning, vlm should be take care before load in vlsu")
//           sbInfo.splitInfo(i).fun.lbu := ori.vAttach.get.vWidth === "b000".U
//           sbInfo.splitInfo(i).fun.lhu := ori.vAttach.get.vWidth === "b001".U
//           sbInfo.splitInfo(i).fun.lwu := ori.vAttach.get.vWidth === "b010".U
//           sbInfo.splitInfo(i).fun.ld  := ori.vAttach.get.vWidth === "b011".U

//           sbInfo.splitInfo(i).param.dat.op1 := ori.param.dat.op1(63,0) + adjAddr( i, ori.vAttach.get.nf, ori.vAttach.get.vWidth )
//           sbInfo.splitInfo(i).param.dat.op2 := DontCare

//           sbInfo.isExeReady := true.B
//         }.elsewhen( iss.fun.vse | iss.fun.vsm ){
//           println("Warning, vsm should be take care before load in vlsu")
//           sbInfo.splitInfo(i).fun.sb := ori.vAttach.get.vWidth === "b000".U
//           sbInfo.splitInfo(i).fun.sh := ori.vAttach.get.vWidth === "b001".U
//           sbInfo.splitInfo(i).fun.sw := ori.vAttach.get.vWidth === "b010".U
//           sbInfo.splitInfo(i).fun.sd := ori.vAttach.get.vWidth === "b011".U

//           sbInfo.splitInfo(i).param.dat.op1 := ori.param.dat.op1(63,0) + adjAddr( i, ori.vAttach.get.nf, ori.vAttach.get.vWidth )
//           sbInfo.splitInfo(i).param.dat.op2 := adjVS3Ele( ori.param.dat.op3, i, ori.vAttach.get.nf, vsew = ori.vAttach.get.vWidth )

//           sbInfo.isExeReady := false.B
//         }.elsewhen( iss.fun.vlse ){
//           sbInfo.splitInfo(i).fun.lbu := ori.vAttach.get.vWidth === "b000".U
//           sbInfo.splitInfo(i).fun.lhu := ori.vAttach.get.vWidth === "b001".U
//           sbInfo.splitInfo(i).fun.lwu := ori.vAttach.get.vWidth === "b010".U
//           sbInfo.splitInfo(i).fun.ld  := ori.vAttach.get.vWidth === "b011".U
           
//           sbInfo.splitInfo(i).param.dat.op1 := ori.param.dat.op1(63,0) + adjAddr( i, ori.vAttach.get.nf, ori.vAttach.get.vWidth ) + ori.param.dat.op2(63,0) * i.U
//           sbInfo.splitInfo(i).param.dat.op2 := DontCare   

//           sbInfo.isExeReady := true.B           
//         }.elsewhen( iss.fun.vsse ){
//           sbInfo.splitInfo(i).fun.sb := ori.vAttach.get.vWidth === "b000".U
//           sbInfo.splitInfo(i).fun.sh := ori.vAttach.get.vWidth === "b001".U
//           sbInfo.splitInfo(i).fun.sw := ori.vAttach.get.vWidth === "b010".U
//           sbInfo.splitInfo(i).fun.sd := ori.vAttach.get.vWidth === "b011".U
           
//           sbInfo.splitInfo(i).param.dat.op1 := ori.param.dat.op1(63,0) + adjAddr( i, ori.vAttach.get.nf, ori.vAttach.get.vWidth ) + ori.param.dat.op2(63,0) * i.U
//           sbInfo.splitInfo(i).param.dat.op2 := adjVSEle( ori.param.dat.op3, i, ori.vAttach.get.nf, vsew = ori.vAttach.get.vWidth )

//           sbInfo.isExeReady := false.B
//         }.elsewhen( iss.fun.vloxei ){
//           sbInfo.splitInfo(i).fun.lbu := ori.vAttach.get.vWidth === "b000".U
//           sbInfo.splitInfo(i).fun.lhu := ori.vAttach.get.vWidth === "b001".U
//           sbInfo.splitInfo(i).fun.lwu := ori.vAttach.get.vWidth === "b010".U
//           sbInfo.splitInfo(i).fun.ld  := ori.vAttach.get.vWidth === "b011".U
           
//           sbInfo.splitInfo(i).param.dat.op1 := ori.param.dat.op1(63,0) + adjAddr( i, ori.vAttach.get.nf, ori.vAttach.get.vWidth ) + adjVSEle( ori.param.dat.op2, i, "b000".U, ori.vAttach.get.vsew ) 
//           sbInfo.splitInfo(i).param.dat.op2 := DontCare

//           sbInfo.isExeReady := true.B
//         }.elsewhen( iss.fun.vsoxei ){
//           sbInfo.splitInfo(i).fun.sb := ori.vAttach.get.vWidth === "b000".U
//           sbInfo.splitInfo(i).fun.sh := ori.vAttach.get.vWidth === "b001".U
//           sbInfo.splitInfo(i).fun.sw := ori.vAttach.get.vWidth === "b010".U
//           sbInfo.splitInfo(i).fun.sd := ori.vAttach.get.vWidth === "b011".U
           
//           sbInfo.splitInfo(i).param.dat.op1 := ori.param.dat.op1(63,0) + adjAddr( i, ori.vAttach.get.nf, ori.vAttach.get.vWidth ) + adjVSEle( ori.param.dat.op2, i, "b000".U, ori.vAttach.get.vsew ) 
//           sbInfo.splitInfo(i).param.dat.op2 := adjVSEle( ori.param.dat.op3, i, ori.vAttach.get.nf, ori.vAttach.get.vsew )

//           sbInfo.isExeReady := false.B
//         }.elsewhen( iss.fun.vlNreN ){

//           sbInfo.splitInfo(i).fun.lbu := true.B//ori.param.vWidth === "b000".U
//           // sbInfo.splitInfo(i).fun.lhu := ori.param.vWidth === "b001".U
//           // sbInfo.splitInfo(i).fun.lwu := ori.param.vWidth === "b010".U
//           // sbInfo.splitInfo(i).fun.ld := ori.param.vWidth === "b011".U

//           sbInfo.splitInfo(i).param.dat.op1 := ori.param.dat.op1(63,0) + ((ori.vAttach.get.nf + 1.U) << log2Ceil(vParams.vlen/8)) + adjAddr( i, nf = "b000".U, vWidth = "b000".U )
//           sbInfo.splitInfo(i).param.dat.op2 := DontCare

//           sbInfo.isExeReady := true.B
//         }.elsewhen( iss.fun.vsNr ){

//           sbInfo.splitInfo(i).fun.sb := true.B//ori.param.vWidth === "b000".U
//           // sbInfo.splitInfo(i).fun.sh := ori.param.vWidth === "b001".U
//           // sbInfo.splitInfo(i).fun.sw := ori.param.vWidth === "b010".U
//           // sbInfo.splitInfo(i).fun.sd := ori.param.vWidth === "b011".U

//           sbInfo.splitInfo(i).param.dat.op1 := ori.param.dat.op1(63,0) + ((ori.vAttach.get.nf + 1.U) << log2Ceil(vParams.vlen/8)) + adjAddr( i, nf = "b000".U, vWidth = "b000".U )
//           sbInfo.splitInfo(i).param.dat.op2 := adjVSEle( ori.param.dat.op3, i, nf = "b000".U, vsew = "b000".U )
//           sbInfo.isExeReady := false.B
//         }.otherwise{
//           assert(false.B, "Assert Failed, a none Vector LSU instr is push into the VScoreboard!")
//         }

//       }
//     }


//     return sbInfo
//   }
// }

